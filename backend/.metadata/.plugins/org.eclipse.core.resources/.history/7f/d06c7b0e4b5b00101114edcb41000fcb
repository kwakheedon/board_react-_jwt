//package com.example.board.security.jwt;
//
//import java.io.IOException;
//
//import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
//import org.springframework.security.core.context.SecurityContextHolder;
//import org.springframework.security.core.userdetails.UserDetails;
//import org.springframework.stereotype.Component;
//import org.springframework.web.filter.OncePerRequestFilter;
//
//import jakarta.servlet.FilterChain;
//import jakarta.servlet.ServletException;
//import jakarta.servlet.http.HttpServletRequest;
//import jakarta.servlet.http.HttpServletResponse;
//import lombok.RequiredArgsConstructor;
//
//
//// 모든 API 요청을 가로채서 헤더의 JWT 토큰을 검증하는 필터입니다.
////토큰이 유효하면, 해당 사용자를 인증된 상태로 만들어줍니다.
//
//@Component
//@RequiredArgsConstructor
//public class JwtAuthenticationFilter extends OncePerRequestFilter {
//
//    private final JwtUtil jwtUtil;
//    private final CustomUserDetailsService customUserDetailsService;
//
//    @Override
//    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
//        // 1. 요청 헤더에서 토큰을 꺼냅니다.
//        String token = jwtUtil.resolveToken(request);
//
//        // 2. 토큰이 존재하고 유효한 경우에만 인증 절차를 진행합니다.
//        if (token != null && jwtUtil.validateToken(token)) {
//            // 3. 토큰에서 사용자 ID를 추출합니다.
//            Long userId = jwtUtil.getUserIdFromToken(token);
//            
//            // 4. UserDetailsService를 통해 사용자 정보를 조회하고 UserDetails 객체를 받습니다.
//            // (주의: CustomUserDetailsService는 email로 사용자를 찾도록 되어 있으므로,
//            // 더 정확한 구현을 위해서는 토큰에 email을 담거나, UserDetailsService가 ID로도 찾을 수 있도록 해야 합니다.
//            // 여기서는 현재 구조를 유지하기 위해 ID로 사용자를 찾는다고 가정합니다.)
//            // -> 이 문제를 해결하기 위해 CustomUserDetailsService를 ID로 찾도록 수정하는 것이 더 좋습니다.
//            // 아래는 CustomUserDetailsService가 email로 찾는 것을 기준으로, DB에서 email을 다시 조회하는 예시입니다.
//            // Member member = memberRepository.findById(userId).orElse(null);
//            // if (member != null) {
//            //    UserDetails userDetails = customUserDetailsService.loadUserByUsername(member.getEmail());
//            //    ...
//            // }
//            // 위 방식은 비효율적이므로, CustomUserDetailsService에 ID로 찾는 메소드를 추가하는 것을 권장합니다.
//            // 여기서는 가장 일반적인 방식인, username(email)으로 찾는 로직을 기준으로 작성하겠습니다.
//            // 이를 위해 JwtUtil에서 email을 가져오는 메소드가 필요합니다.
//            // String email = jwtUtil.getEmailFromToken(token);
//            // UserDetails userDetails = customUserDetailsService.loadUserByUsername(email);
//            
//            // 현재 JwtUtil 구조를 유지하기 위해, 아래와 같이 ID로 조회한다고 가정하고 진행합니다.
//            // CustomUserDetailsService에 loadUserById(Long id) 메소드를 추가해야 합니다.
//            UserDetails userDetails = customUserDetailsService.loadUserById(userId);
//
//            // 5. 인증 객체를 생성하여 SecurityContext에 저장합니다.
//            UsernamePasswordAuthenticationToken authentication =
//                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
//            SecurityContextHolder.getContext().setAuthentication(authentication);
//        }
//
//        // 6. 다음 필터로 요청을 전달합니다.
//        filterChain.doFilter(request, response);
//    }
//}
//
//// CustomUserDetailsService.java에 아래 메소드를 추가해야 합니다.
///*
//public UserDetails loadUserById(Long id) throws UsernameNotFoundException {
//    Member member = memberRepository.findById(id)
//            .orElseThrow(() -> new UsernameNotFoundException("해당 ID의 사용자를 찾을 수 없습니다: " + id));
//    return new CustomUserDetails(member);
//}
//*/